{
  "name": "watershed",
  "version": "0.3.0",
  "description": "simple websockets (RFC6455) client and server",
  "main": "./lib/watershed.js",
  "author": {
    "name": "Joshua M. Clulow",
    "email": "jmc@joyent.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/jclulow/node-watershed.git"
  },
  "dependencies": {
    "readable-stream": "1.0.2",
    "dtrace-provider": "0.2.8"
  },
  "optionalDependencies": {
    "dtrace-provider": "0.2.8"
  },
  "engines": [
    "node >=0.8.0"
  ],
  "readme": "# node-watershed\n\nA simple implementation of WebSockets for use with node.js 'http'-style web\nserver or client.  Deals only with [RFC6455][1], ignoring any Browser-specific\npeculiarities, curiosities, and fallback mechanisms.\n\n## API\n\n### Watershed\n\nThe core of this library is a Factory-style class `Watershed`.  It has several\nstatic methods:\n\n#### Watershed.accept(http.ServerRequest, net.Socket, Buffer)\n\nResponds to a client's request to Upgrade an HTTP connection to a WebSocket and\nreturns a `WatershedConnection`, which is also an `EventEmitter`.\n\nThe arguments to this method should ideally come from the `'upgrade'` event on\na node.js `http.Server`.  For example:\n\n```javascript\nvar shed = new Watershed();\nvar srv = http.createServer();\nsrv.listen(8080);\nsrv.on('upgrade', function(req, socket, head) {\n        var wsc;\n        try {\n                wsc = shed.accept(req, socket, head);\n        } catch (ex) {\n                console.error('error: ' + ex.message);\n                return socket.end();\n        }\n        wsc.on('text', function(text) {\n                console.log('received text: ' + text);\n        });\n        wsc.on('end', function() {\n                console.log('end!');\n        });\n        /* ... etc ... */\n});\n```\n\n#### Watershed.generateKey()\n\nReturns a random, Base64-encoded 16-byte value suitable for use as the\n`Sec-WebSocket-Key` header on an Upgrade request.  See Example usage in\n`connect()`.\n\n#### Watershed.connect(http.ClientResponse, net.Socket, Buffer, String)\n\nAttaches a new client-side `WatershedConnection` to this presently Upgraded\nsocket.\n\nThe arguments to this method should ideally come from the `'upgrade'` event on\na node.js `http.Client`.  For example:\n\n```javascript\nvar shed = new Watershed();\nvar wskey = ws.generateKey();\nvar options = {\n    port: 8082,\n    hostname: '127.0.0.1',\n    headers: {\n        'connection': 'upgrade',\n        'upgrade': 'websocket',\n        'Sec-WebSocket-Key': wskey\n    }\n};\nvar req = http.request(options);\nreq.end();\nreq.on('upgrade', function(res, socket, head) {\n        var wsc = shed.connect(res, socket, head, wskey);\n        wsc.send('Hi there!');\n        wsc.on('end', function() {\n                console.log('end!');\n        });\n        /* ... etc ... */\n});\n```\n\n### WatershedConnection\n\n#### Event: 'error'\n\nEmitted once when an error occurs during processing.  The socket will be closed\nand an `'end'` event will follow.  The only argument will be an instance of\n`Error`.\n\n#### Event: 'connectionReset'\n\nEmitted when the remote peer closes the connection without sending us a CLOSE\nframe.  An `'end'` event will follow.\n\n#### Event: 'end' (code, reason)\n\nEmitted once when the socket is closing.  If we received a graceful CLOSE\nframe from the remote server, we will attempt to process it and pass `code`\nand `reason` -- both of type `String`.\n\n#### Event: 'text'\n\nEmitted for each inbound TEXT frame.  The only argument will be a `String`\ncontaining the UTF-8 string payload.\n\n#### Event: 'binary'\n\nEmitted for each inbound BINARY frame.  The only argument will be a `Buffer`\ncontaining the binary payload.\n\n#### Event: 'ping'\n\nEmitted for each inbound PING frame.  The only argument will be a `Buffer`\ncontaining the nonce in the ping request.  Note that the library presently\nresponds with a PONG frame for each inbound PING frame.\n\n#### Event: 'pong'\n\nEmitted for each inbound PONG frame.  The only argument will be a `Buffer`\ncontaining the nonce in the pong response.\n\n#### WatershedConnection.send(data)\n\nSends a frame through the socket.  The single argument `data` may be a\n`Buffer`, in which case a BINARY frame is sent; or a `String`, in which case a\nTEXT frame is sent.\n\n#### WatershedConnection.end(reason)\n\nCloses the connection.  The RFC allows a reason for closing the connection to\nbe send in the CLOSE frame, though this is optional.  If passed, `reason`\nshould be a `String`.\n\n#### WatershedConnection.destroy()\n\nImmediately destroy the underlying socket, without sending a CLOSE frame.  You\ngenerally want `end()`, rather than this, in order to perform RFC-compliant\nconnection shutdowns.\n\n## License\n\nMIT.\n\n[1]: http://tools.ietf.org/html/rfc6455\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/jclulow/node-watershed/issues"
  },
  "homepage": "https://github.com/jclulow/node-watershed",
  "_id": "watershed@0.3.0",
  "_shasum": "38c4995b3ccc9b1bef767a480054d1c7340578bb",
  "_resolved": "https://registry.npmjs.org/watershed/-/watershed-0.3.0.tgz",
  "_from": "https://registry.npmjs.org/watershed/-/watershed-0.3.0.tgz",
  "scripts": {}
}
